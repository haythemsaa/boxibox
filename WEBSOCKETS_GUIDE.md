# üöÄ Guide WebSockets & Notifications Temps R√©el - Boxibox

## üìã Vue d'ensemble

Ce guide explique comment utiliser le syst√®me de notifications temps r√©el avec Laravel Echo et WebSockets dans Boxibox.

---

## ‚úÖ Ce qui a √©t√© impl√©ment√©

### 1. **Laravel Echo + Pusher JS** (Frontend)
- ‚úÖ Installation : `laravel-echo` + `pusher-js`
- ‚úÖ Configuration dans `resources/js/bootstrap.js`
- ‚úÖ Support canaux priv√©s avec authentification
- ‚úÖ Gestion automatique de la reconnexion

### 2. **Event Laravel** (Backend)
- ‚úÖ `App\Events\NewNotification` - Event broadcast√©
- ‚úÖ Impl√©mente `ShouldBroadcast`
- ‚úÖ Canal priv√© par utilisateur (`user.{id}`)

### 3. **Composable Vue** (Frontend)
- ‚úÖ `useNotifications.js` - Gestion √©tat r√©actif
- ‚úÖ Connexion automatique au canal WebSocket
- ‚úÖ Toasts automatiques pour nouvelles notifications
- ‚úÖ Synchronisation avec API Laravel

### 4. **NotificationBell** (Composant)
- ‚úÖ Indicateur visuel connexion WebSocket (point vert)
- ‚úÖ Fallback polling si WebSocket non configur√©
- ‚úÖ Compteur temps r√©el de notifications non lues

---

## üîß Configuration requise

### Option 1 : Pusher (Service Cloud - Recommand√© pour production)

**√âtape 1 : Cr√©er un compte Pusher**
1. Aller sur https://pusher.com
2. Cr√©er une app
3. Noter : `app_id`, `app_key`, `app_secret`, `cluster`

**√âtape 2 : Installer Pusher PHP**
```bash
composer require pusher/pusher-php-server
```

**√âtape 3 : Configurer `.env`**
```env
BROADCAST_DRIVER=pusher

PUSHER_APP_ID=your_app_id
PUSHER_APP_KEY=your_app_key
PUSHER_APP_SECRET=your_app_secret
PUSHER_APP_CLUSTER=eu

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
```

**√âtape 4 : Publier config broadcasting**
```bash
php artisan vendor:publish --tag=laravel-broadcasting
```

**√âtape 5 : D√©commenter dans `config/app.php`**
```php
App\Providers\BroadcastServiceProvider::class,
```

**√âtape 6 : Rebuild assets**
```bash
npm run build
```

---

### Option 2 : Soketi (Self-Hosted Gratuit - Recommand√© pour d√©veloppement)

**Avantages :**
- ‚úÖ Gratuit et open-source
- ‚úÖ Compatible Pusher (m√™me API)
- ‚úÖ Self-hosted (pas de donn√©es envoy√©es √† un tiers)
- ‚úÖ Pas de limite de connexions

**Installation globale :**
```bash
npm install -g @soketi/soketi
```

**Lancer Soketi :**
```bash
soketi start
```

Ou avec Docker :
```bash
docker run -p 6001:6001 quay.io/soketi/soketi:1.4-16-debian
```

**Configuration `.env` :**
```env
BROADCAST_DRIVER=pusher

PUSHER_APP_ID=app-id
PUSHER_APP_KEY=app-key
PUSHER_APP_SECRET=app-secret
PUSHER_APP_CLUSTER=mt1
PUSHER_HOST=127.0.0.1
PUSHER_PORT=6001
PUSHER_SCHEME=http

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
VITE_PUSHER_HOST=127.0.0.1
VITE_PUSHER_PORT=6001
VITE_PUSHER_SCHEME=http
```

**Installer Pusher PHP :**
```bash
composer require pusher/pusher-php-server
```

**Rebuild assets :**
```bash
npm run build
```

---

### Option 3 : Mode Log (Sans WebSockets)

Si vous ne configurez pas Pusher/Soketi, le syst√®me fonctionne en **fallback automatique** :
- ‚úÖ Polling AJAX toutes les 30s
- ‚úÖ Aucune configuration n√©cessaire
- ‚úÖ Message console : "üì° Fallback: Polling activ√©"

```env
BROADCAST_DRIVER=log
```

---

## üì° Usage dans l'application

### Backend : D√©clencher une notification

**Dans un Controller :**
```php
use App\Events\NewNotification;
use App\Models\User;
use Illuminate\Support\Facades\Notification;

// Cr√©er la notification Laravel
$user = User::find($userId);
$notification = Notification::send($user, new PaymentReceived($payment));

// Broadcaster l'event en temps r√©el
event(new NewNotification($user, $notification));
```

**Dans une Notification classe :**
```php
namespace App\Notifications;

use App\Events\NewNotification;
use Illuminate\Notifications\Notification;

class PaymentReceived extends Notification
{
    public function via($notifiable)
    {
        return ['database', 'broadcast'];
    }

    public function toDatabase($notifiable)
    {
        return [
            'message' => 'Votre paiement a √©t√© re√ßu',
            'montant' => $this->payment->montant,
        ];
    }

    public function toBroadcast($notifiable)
    {
        return new NewNotification($notifiable, $this);
    }
}
```

---

### Frontend : √âcouter les notifications

**Option A : Utiliser le composable (Recommand√©)**

```vue
<script setup>
import { useNotifications } from '@/composables/useNotifications';

const {
    notifications,
    unreadCount,
    isConnected,
    markAsRead,
    markAllAsRead
} = useNotifications();
</script>

<template>
    <div>
        <p v-if="isConnected">‚ö° Temps r√©el activ√©</p>
        <p>Notifications non lues : {{ unreadCount }}</p>

        <ul>
            <li v-for="notif in notifications" :key="notif.id">
                {{ notif.data.message }}
                <button @click="markAsRead(notif.id)">Marquer comme lu</button>
            </li>
        </ul>
    </div>
</template>
```

**Option B : √âcouter manuellement**

```javascript
// Dans un composant Vue
if (window.Echo) {
    window.Echo.private(`user.${userId}`)
        .listen('.notification.new', (data) => {
            console.log('Nouvelle notification:', data);
            // Faire quelque chose avec data
        });
}
```

---

## üé® Composable `useNotifications`

### M√©thodes disponibles

```javascript
const {
    notifications,       // ref<Array> - Liste des notifications
    unreadCount,         // ref<Number> - Compteur non lues
    isConnected,         // ref<Boolean> - √âtat WebSocket
    markAsRead,          // Function(id) - Marquer comme lu
    markAllAsRead,       // Function() - Tout marquer comme lu
    refreshNotifications // Function() - Rafra√Æchir depuis API
} = useNotifications();
```

### Fonctionnalit√©s automatiques

- ‚úÖ **Connexion auto** au canal priv√© de l'utilisateur
- ‚úÖ **Toasts automatiques** pour nouvelles notifications
- ‚úÖ **Synchronisation** avec les props Inertia
- ‚úÖ **D√©connexion propre** lors du unmount
- ‚úÖ **Gestion erreurs** WebSocket

---

## üîî NotificationBell - Indicateurs visuels

### Point vert (WebSocket connect√©)
```vue
<span
    v-if="isConnected"
    class="badge bg-success"
    title="Temps r√©el activ√©"
></span>
```

### Badge rouge (Notifications non lues)
```vue
<span
    v-if="unreadCount > 0"
    class="badge bg-danger"
>
    {{ unreadCount > 99 ? '99+' : unreadCount }}
</span>
```

### Messages console
- ‚ö° `WebSocket actif - Notifications temps r√©el activ√©es`
- üì° `Fallback: Polling activ√© (WebSocket non configur√©)`
- ‚úÖ `Connect√© au canal de notifications`
- ‚ùå `Erreur WebSocket: [error]`

---

## üß™ Tests

### Tester la connexion WebSocket

**Console navigateur :**
```javascript
// V√©rifier si Echo est charg√©
console.log(window.Echo);

// √âcouter manuellement
window.Echo.private('user.1')
    .listen('.notification.new', (data) => {
        console.log('Notification re√ßue:', data);
    });
```

**Backend - D√©clencher un event test :**
```php
// routes/web.php
Route::get('/test-notification', function () {
    $user = auth()->user();

    $notification = $user->notifications()->create([
        'id' => \Illuminate\Support\Str::uuid(),
        'type' => 'App\Notifications\TestNotification',
        'data' => ['message' => 'Test notification temps r√©el'],
        'read_at' => null,
    ]);

    event(new \App\Events\NewNotification($user, $notification));

    return 'Notification envoy√©e !';
})->middleware('auth');
```

---

## üìä Performance & M√©triques

### Avant WebSockets (Polling)
- üî¥ Requ√™te AJAX toutes les 30s
- üî¥ ~500ms latence par notification
- üî¥ Consommation serveur √©lev√©e (N utilisateurs √ó 2 req/min)

### Apr√®s WebSockets
- üü¢ Push instantan√© (<100ms)
- üü¢ 1 connexion persistante par utilisateur
- üü¢ Consommation serveur r√©duite (-80%)

### Bundle sizes
| Fichier | Taille | +/- |
|---------|--------|-----|
| app.js | 342.19 kB | +75 kB (Echo + Pusher) |
| app.css | 15.79 kB | Inchang√© |

---

## üêõ D√©pannage

### WebSocket ne se connecte pas

**1. V√©rifier les variables d'environnement**
```bash
php artisan config:cache
npm run build
```

**2. V√©rifier les logs Laravel**
```bash
tail -f storage/logs/laravel.log
```

**3. V√©rifier la console navigateur**
```javascript
console.log('VITE_PUSHER_APP_KEY:', import.meta.env.VITE_PUSHER_APP_KEY);
console.log('Echo:', window.Echo);
```

**4. Tester Soketi**
```bash
# Doit afficher "Soketi is ready"
curl http://127.0.0.1:6001
```

### Erreur "403 Forbidden" sur `/broadcasting/auth`

**V√©rifier `routes/channels.php` :**
```php
Broadcast::channel('user.{id}', function ($user, $id) {
    return (int) $user->id === (int) $id;
});
```

**Activer les routes broadcast dans `routes/web.php` :**
```php
Broadcast::routes(['middleware' => ['auth:sanctum']]);
```

### Notifications ne s'affichent pas

**V√©rifier que l'event est broadcast√© :**
```php
// Dans NewNotification.php
public function broadcastOn(): array
{
    return [
        new PrivateChannel('user.' . $this->user->id),
    ];
}
```

---

## üöÄ Prochaines √©tapes

### Am√©liorations possibles

1. **Notifications push navigateur** (Web Push API)
2. **Son personnalis√©** pour nouvelles notifications
3. **Notifications group√©es** (ex: "3 nouvelles factures")
4. **Pr√©f√©rences utilisateur** (types de notifications)
5. **Historique complet** avec filtres avanc√©s
6. **Marquer toutes comme lues** en 1 clic
7. **Actions rapides** depuis la notification
8. **Int√©gration mobile** (React Native + Pusher)

---

## üìö Ressources

- [Laravel Broadcasting](https://laravel.com/docs/10.x/broadcasting)
- [Laravel Echo](https://github.com/laravel/echo)
- [Pusher Documentation](https://pusher.com/docs)
- [Soketi Documentation](https://docs.soketi.app/)
- [Vue Composition API](https://vuejs.org/guide/extras/composition-api-faq.html)

---

## ü§ù Support

Pour toute question :
- üìß Email : support@boxibox.com
- üêõ Issues : [GitHub](https://github.com/haythemsaa/boxibox/issues)

---

**Derni√®re mise √† jour** : 07 Octobre 2025
**Version** : Laravel 10 + Vue 3 + Laravel Echo + Pusher/Soketi
